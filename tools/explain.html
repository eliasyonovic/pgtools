<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>pgexplain - EXPLAIN ANALYZE Visualizer | pgtools</title>
<link rel="stylesheet" href="../style.css">
<style>
  .explain-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 16px; }
  @media (max-width: 900px) { .explain-layout { grid-template-columns: 1fr; } }

  .node-tree { padding: 16px; }
  .plan-node {
    border-left: 2px solid var(--border);
    padding: 8px 0 8px 16px;
    margin-left: 8px;
    position: relative;
  }
  .plan-node::before {
    content: '';
    position: absolute;
    left: -2px;
    top: 18px;
    width: 12px;
    height: 2px;
    background: var(--border);
  }
  .plan-node:last-child { border-left-color: transparent; }
  .plan-node:last-child::after {
    content: '';
    position: absolute;
    left: -2px;
    top: 0;
    width: 2px;
    height: 18px;
    background: var(--border);
  }
  .node-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 14px;
    margin-bottom: 4px;
    transition: border-color 0.15s;
  }
  .node-card:hover { border-color: var(--accent); }
  .node-card.hot { border-left: 3px solid var(--red); }
  .node-card.warm { border-left: 3px solid var(--yellow); }
  .node-card.cool { border-left: 3px solid var(--green); }
  .node-type { font-weight: 600; font-size: 0.9rem; }
  .node-detail { font-size: 0.8rem; color: var(--muted); margin-top: 4px; line-height: 1.5; }
  .node-detail code { background: rgba(99,102,241,0.1); color: var(--accent-hover); padding: 1px 4px; border-radius: 3px; }
  .node-bars { display: flex; gap: 8px; margin-top: 6px; flex-wrap: wrap; }
  .node-bar {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.75rem;
  }
  .bar-track { width: 60px; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; }
  .bar-fill { height: 100%; border-radius: 3px; }
  .bar-fill.red { background: var(--red); }
  .bar-fill.yellow { background: var(--yellow); }
  .bar-fill.green { background: var(--green); }
  .bar-fill.accent { background: var(--accent); }
  .bar-label { color: var(--muted); white-space: nowrap; }

  .summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px; }
  .summary-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px;
  }
  .summary-card h4 { font-size: 0.8rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
  .summary-card .value { font-size: 1.4rem; font-weight: 700; }
  .summary-card .sub { font-size: 0.8rem; color: var(--muted); margin-top: 2px; }

  .findings-section { margin-top: 16px; }
</style>
</head>
<body>
<nav>
  <div class="brand"><span>pg</span>tools</div>
  <div class="tools">
    <a href="../">Home</a>
    <a href="./sheet.html">Sheet</a>
    <a href="./query.html">Query</a>
    <a href="./schema.html">Schema</a>
    <a href="./explain.html" class="active">Explain</a>
  </div>
</nav>
<div class="container">
  <div class="page-header">
    <h2><span style="color:var(--accent)">pg</span>explain</h2>
    <p>Paste your EXPLAIN ANALYZE output. See where time is spent.</p>
  </div>

  <div class="controls">
    <button class="btn btn-primary" onclick="analyze()">Analyze</button>
    <span style="flex:1"></span>
    <span class="sample-link" onclick="loadSample()">Load sample plan</span>
  </div>

  <div class="panel">
    <div class="panel-header"><h3>EXPLAIN ANALYZE Output</h3></div>
    <textarea id="input" placeholder="Paste your EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT) output here..." style="min-height:200px"></textarea>
  </div>

  <div id="results" style="display:none">
    <div class="summary-grid" id="summaryGrid"></div>

    <div class="findings-section" id="findingsSection" style="display:none">
      <div class="panel" style="margin-top:16px">
        <div class="panel-header"><h3>Findings</h3><span id="findingsCount"></span></div>
        <div class="info-panel"><ul class="findings" id="findingsList"></ul></div>
      </div>
    </div>

    <div class="panel" style="margin-top:16px">
      <div class="panel-header"><h3>Plan Tree</h3></div>
      <div class="node-tree" id="planTree"></div>
    </div>
  </div>
</div>

<script>
const $ = id => document.getElementById(id);

function parsePlan(text) {
  const lines = text.trim().split('\n');
  const nodes = [];
  const stack = [{ children: nodes, indent: -1 }];

  for (const line of lines) {
    // Skip non-plan lines
    if (!line.match(/^\s*(->)?\s*\w/) && !line.match(/^\s*\w+/)) continue;
    if (line.match(/^\s*(Planning|Execution|Total|Trigger|Settings|JIT)/i)) continue;

    // Parse plan node line
    const nodeMatch = line.match(/^(\s*)(->)?\s*(.+)/);
    if (!nodeMatch) continue;

    const indent = nodeMatch[1].length + (nodeMatch[2] ? 3 : 0);
    const content = nodeMatch[3].trim();

    // Parse node type and details
    const typeMatch = content.match(/^(\w[\w\s]*?)\s+(?:on\s+(\S+)\s+)?(?:using\s+(\S+)\s+)?\((.+)\)/i);
    if (!typeMatch && !content.match(/^\w/)) continue;

    const node = { raw: content, children: [], indent };

    if (typeMatch) {
      node.type = typeMatch[1].trim();
      node.on = typeMatch[2] || null;
      node.using = typeMatch[3] || null;
      const params = typeMatch[4];

      // Parse cost, rows, width
      const costMatch = params.match(/cost=(\d+\.?\d*)\.\.(\d+\.?\d*)\s+rows=(\d+)\s+width=(\d+)/);
      if (costMatch) {
        node.startupCost = parseFloat(costMatch[1]);
        node.totalCost = parseFloat(costMatch[2]);
        node.estRows = parseInt(costMatch[3]);
        node.width = parseInt(costMatch[4]);
      }

      // Parse actual time, rows, loops
      const actualMatch = params.match(/actual time=(\d+\.?\d*)\.\.(\d+\.?\d*)\s+rows=(\d+)\s+loops=(\d+)/);
      if (actualMatch) {
        node.actualStartup = parseFloat(actualMatch[1]);
        node.actualTotal = parseFloat(actualMatch[2]);
        node.actualRows = parseInt(actualMatch[3]);
        node.loops = parseInt(actualMatch[4]);
      }
    } else {
      // Simple line - might be a detail
      node.type = content.split('(')[0].trim();
      const parens = content.match(/\((.+)\)/);
      if (parens) {
        const costMatch = parens[1].match(/cost=(\d+\.?\d*)\.\.(\d+\.?\d*)\s+rows=(\d+)\s+width=(\d+)/);
        if (costMatch) {
          node.startupCost = parseFloat(costMatch[1]);
          node.totalCost = parseFloat(costMatch[2]);
          node.estRows = parseInt(costMatch[3]);
          node.width = parseInt(costMatch[4]);
        }
        const actualMatch = parens[1].match(/actual time=(\d+\.?\d*)\.\.(\d+\.?\d*)\s+rows=(\d+)\s+loops=(\d+)/);
        if (actualMatch) {
          node.actualStartup = parseFloat(actualMatch[1]);
          node.actualTotal = parseFloat(actualMatch[2]);
          node.actualRows = parseInt(actualMatch[3]);
          node.loops = parseInt(actualMatch[4]);
        }
      }
    }

    if (!node.type || node.type.length > 80) continue;

    // Build tree based on indentation
    while (stack.length > 1 && stack[stack.length - 1].indent >= indent) stack.pop();
    stack[stack.length - 1].children.push(node);
    stack.push(node);
  }

  // Parse planning/execution time
  let planningTime = 0, executionTime = 0;
  const planMatch = text.match(/Planning Time:\s*(\d+\.?\d*)\s*ms/i);
  const execMatch = text.match(/Execution Time:\s*(\d+\.?\d*)\s*ms/i);
  if (planMatch) planningTime = parseFloat(planMatch[1]);
  if (execMatch) executionTime = parseFloat(execMatch[1]);

  return { nodes, planningTime, executionTime };
}

function getMaxTime(nodes) {
  let max = 0;
  function walk(n) {
    if (n.actualTotal) max = Math.max(max, n.actualTotal * (n.loops || 1));
    (n.children || []).forEach(walk);
  }
  nodes.forEach(walk);
  return max;
}

function analyzeFindings(nodes) {
  const findings = [];
  function walk(n) {
    if (n.type && n.type.includes('Seq Scan') && n.actualRows > 1000) {
      findings.push({ level: 'warn', message: 'Sequential Scan on ' + (n.on || 'table') + ' returned ' + n.actualRows.toLocaleString() + ' rows. Consider adding an index.' });
    }
    if (n.estRows && n.actualRows !== undefined) {
      const ratio = n.estRows > 0 ? n.actualRows / n.estRows : 0;
      if (ratio > 10 || (n.estRows > 0 && ratio < 0.1)) {
        findings.push({ level: 'warn', message: 'Row estimate off by ' + (ratio > 1 ? ratio.toFixed(0) + 'x too low' : (1/ratio).toFixed(0) + 'x too high') + ' on ' + n.type + (n.on ? ' on ' + n.on : '') + ' (est: ' + n.estRows + ', actual: ' + n.actualRows + '). Run ANALYZE.' });
      }
    }
    if (n.type && n.type.includes('Nested Loop') && n.loops > 100) {
      findings.push({ level: 'info', message: 'Nested Loop with ' + n.loops + ' iterations' + (n.on ? ' on ' + n.on : '') + '. Consider if a Hash Join would be better.' });
    }
    if (n.type && n.type.includes('Sort') && n.raw && n.raw.includes('external')) {
      findings.push({ level: 'warn', message: 'Sort spilled to disk. Increase work_mem or add an index to avoid sorting.' });
    }
    (n.children || []).forEach(walk);
  }
  nodes.forEach(walk);
  return findings;
}

function renderNode(node, maxTime, depth) {
  const timeMs = node.actualTotal ? (node.actualTotal * (node.loops || 1)) : 0;
  const pct = maxTime > 0 ? (timeMs / maxTime * 100) : 0;
  const heat = pct > 50 ? 'hot' : pct > 20 ? 'warm' : 'cool';

  let html = '<div class="node-card ' + heat + '">';
  html += '<div class="node-type">' + esc(node.type || 'Unknown') + '</div>';

  let details = [];
  if (node.on) details.push('on <code>' + esc(node.on) + '</code>');
  if (node.using) details.push('using <code>' + esc(node.using) + '</code>');
  if (details.length) html += '<div class="node-detail">' + details.join(' ') + '</div>';

  html += '<div class="node-bars">';
  if (node.actualTotal !== undefined) {
    html += '<div class="node-bar"><span class="bar-label">Time: ' + timeMs.toFixed(2) + 'ms</span><div class="bar-track"><div class="bar-fill ' + (pct>50?'red':pct>20?'yellow':'green') + '" style="width:' + Math.max(2,pct) + '%"></div></div></div>';
  }
  if (node.actualRows !== undefined) {
    html += '<div class="node-bar"><span class="bar-label">Rows: ' + node.actualRows.toLocaleString() + '</span></div>';
  }
  if (node.estRows !== undefined && node.actualRows !== undefined) {
    const accuracy = node.estRows > 0 ? Math.min(100, (Math.min(node.actualRows, node.estRows) / Math.max(node.actualRows, node.estRows)) * 100) : 0;
    html += '<div class="node-bar"><span class="bar-label">Est: ' + accuracy.toFixed(0) + '%</span><div class="bar-track"><div class="bar-fill accent" style="width:' + accuracy + '%"></div></div></div>';
  }
  if (node.loops && node.loops > 1) {
    html += '<div class="node-bar"><span class="bar-label">Loops: ' + node.loops + '</span></div>';
  }
  html += '</div></div>';

  if (node.children && node.children.length > 0) {
    for (const child of node.children) {
      html += '<div class="plan-node">' + renderNode(child, maxTime, depth + 1) + '</div>';
    }
  }
  return html;
}

function analyze() {
  const text = $('input').value.trim();
  if (!text) return;

  const plan = parsePlan(text);
  if (plan.nodes.length === 0) {
    $('results').style.display = 'none';
    return;
  }

  const maxTime = getMaxTime(plan.nodes);
  const totalTime = plan.executionTime || maxTime;

  // Summary
  let nodeCount = 0;
  function countNodes(n) { nodeCount++; (n.children||[]).forEach(countNodes); }
  plan.nodes.forEach(countNodes);

  $('summaryGrid').innerHTML =
    '<div class="summary-card"><h4>Total Time</h4><div class="value">' + totalTime.toFixed(2) + ' ms</div><div class="sub">Planning: ' + plan.planningTime.toFixed(2) + ' ms</div></div>' +
    '<div class="summary-card"><h4>Plan Nodes</h4><div class="value">' + nodeCount + '</div><div class="sub">Depth: ' + getDepth(plan.nodes) + '</div></div>' +
    '<div class="summary-card"><h4>Slowest Node</h4><div class="value">' + maxTime.toFixed(2) + ' ms</div><div class="sub">' + esc(getSlowest(plan.nodes).type || '-') + '</div></div>' +
    '<div class="summary-card"><h4>Max Rows</h4><div class="value">' + getMaxRows(plan.nodes).toLocaleString() + '</div></div>';

  // Findings
  const findings = analyzeFindings(plan.nodes);
  if (findings.length > 0) {
    const list = $('findingsList');
    list.innerHTML = '';
    const icons = { error: '!', warn: '?', info: 'i' };
    for (const f of findings) {
      const li = document.createElement('li');
      li.className = f.level === 'error' ? 'error' : f.level === 'warn' ? 'warn' : 'info';
      li.innerHTML = '<span class="icon"><span class="badge badge-' + (f.level==='error'?'red':f.level==='warn'?'yellow':'green') + '">' + icons[f.level] + '</span></span><span>' + f.message + '</span>';
      list.appendChild(li);
    }
    $('findingsCount').innerHTML = '<span class="badge badge-yellow">' + findings.length + '</span>';
    $('findingsSection').style.display = 'block';
  } else $('findingsSection').style.display = 'none';

  // Plan tree
  let treeHtml = '';
  for (const node of plan.nodes) {
    treeHtml += renderNode(node, maxTime, 0);
  }
  $('planTree').innerHTML = treeHtml;
  $('results').style.display = 'block';
}

function getDepth(nodes) {
  let d = 0;
  function walk(n, level) { d = Math.max(d, level); (n.children||[]).forEach(c => walk(c, level+1)); }
  nodes.forEach(n => walk(n, 1));
  return d;
}
function getSlowest(nodes) {
  let best = { actualTotal: 0 };
  function walk(n) { if ((n.actualTotal||0)*(n.loops||1) > (best.actualTotal||0)*(best.loops||1)) best = n; (n.children||[]).forEach(walk); }
  nodes.forEach(walk);
  return best;
}
function getMaxRows(nodes) {
  let max = 0;
  function walk(n) { max = Math.max(max, n.actualRows || 0); (n.children||[]).forEach(walk); }
  nodes.forEach(walk);
  return max;
}
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

let debounce = null;
$('input').addEventListener('input', () => { clearTimeout(debounce); debounce = setTimeout(analyze, 500); });

function loadSample() {
  $('input').value = `Sort  (cost=245.47..247.97 rows=1000 width=52) (actual time=3.512..3.598 rows=1000 loops=1)
  Sort Key: o.created_at DESC
  Sort Method: quicksort  Memory: 102kB
  ->  Hash Join  (cost=28.50..195.60 rows=1000 width=52) (actual time=0.412..2.876 rows=1000 loops=1)
        Hash Cond: (o.user_id = u.id)
        ->  Seq Scan on orders o  (cost=0.00..155.00 rows=5000 width=36) (actual time=0.015..1.234 rows=5000 loops=1)
              Filter: (total > 50.00)
              Rows Removed by Filter: 3200
        ->  Hash  (cost=22.50..22.50 rows=480 width=24) (actual time=0.352..0.354 rows=480 loops=1)
              Buckets: 1024  Batches: 1  Memory Usage: 32kB
              ->  Index Scan using idx_users_active on users u  (cost=0.29..22.50 rows=480 width=24) (actual time=0.021..0.198 rows=480 loops=1)
                    Index Cond: (active = true)
Planning Time: 0.245 ms
Execution Time: 3.782 ms`;
  analyze();
}
</script>
</body>
</html>
